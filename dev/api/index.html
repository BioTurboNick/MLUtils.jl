<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MLUtils.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MLUtils.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Docs"><span>Docs</span></a></li><li><a class="tocitem" href="#Datasets-Docs"><span>Datasets Docs</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaML/MLUtils.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#MLUtils.BatchView"><code>MLUtils.BatchView</code></a></li><li><a href="#MLUtils.DataLoader"><code>MLUtils.DataLoader</code></a></li><li><a href="#MLUtils.ObsView"><code>MLUtils.ObsView</code></a></li><li><a href="#MLUtils.batchview"><code>MLUtils.batchview</code></a></li><li><a href="#MLUtils.batch-Tuple{Any}"><code>MLUtils.batch</code></a></li><li><a href="#MLUtils.batch"><code>MLUtils.batch</code></a></li><li><a href="#MLUtils.batchseq"><code>MLUtils.batchseq</code></a></li><li><a href="#MLUtils.batchsize"><code>MLUtils.batchsize</code></a></li><li><a href="#MLUtils.chunk-Tuple{Any, Any}"><code>MLUtils.chunk</code></a></li><li><a href="#MLUtils.eachobs"><code>MLUtils.eachobs</code></a></li><li><a href="#MLUtils.filterobs"><code>MLUtils.filterobs</code></a></li><li><a href="#MLUtils.flatten-Tuple{AbstractArray}"><code>MLUtils.flatten</code></a></li><li><a href="#MLUtils.getobs"><code>MLUtils.getobs</code></a></li><li><a href="#MLUtils.getobs!"><code>MLUtils.getobs!</code></a></li><li><a href="#MLUtils.group_counts-Tuple{Any}"><code>MLUtils.group_counts</code></a></li><li><a href="#MLUtils.group_indices-Tuple{T} where T&lt;:(AbstractVector)"><code>MLUtils.group_indices</code></a></li><li><a href="#MLUtils.groupobs"><code>MLUtils.groupobs</code></a></li><li><a href="#MLUtils.joinobs"><code>MLUtils.joinobs</code></a></li><li><a href="#MLUtils.kfolds"><code>MLUtils.kfolds</code></a></li><li><a href="#MLUtils.leavepout"><code>MLUtils.leavepout</code></a></li><li><a href="#MLUtils.mapobs"><code>MLUtils.mapobs</code></a></li><li><a href="#MLUtils.normalise-Tuple{AbstractArray}"><code>MLUtils.normalise</code></a></li><li><a href="#MLUtils.numobs"><code>MLUtils.numobs</code></a></li><li><a href="#MLUtils.obsview"><code>MLUtils.obsview</code></a></li><li><a href="#MLUtils.oversample"><code>MLUtils.oversample</code></a></li><li><a href="#MLUtils.randobs"><code>MLUtils.randobs</code></a></li><li><a href="#MLUtils.shuffleobs"><code>MLUtils.shuffleobs</code></a></li><li><a href="#MLUtils.splitobs"><code>MLUtils.splitobs</code></a></li><li><a href="#MLUtils.stack"><code>MLUtils.stack</code></a></li><li><a href="#MLUtils.stack-Tuple{Any}"><code>MLUtils.stack</code></a></li><li><a href="#MLUtils.unbatch"><code>MLUtils.unbatch</code></a></li><li><a href="#MLUtils.unbatch-Tuple{AbstractArray}"><code>MLUtils.unbatch</code></a></li><li><a href="#MLUtils.undersample"><code>MLUtils.undersample</code></a></li><li><a href="#MLUtils.unsqueeze-Tuple{AbstractArray}"><code>MLUtils.unsqueeze</code></a></li><li><a href="#MLUtils.unsqueeze-Tuple{}"><code>MLUtils.unsqueeze</code></a></li><li><a href="#MLUtils.unsqueeze"><code>MLUtils.unsqueeze</code></a></li><li><a href="#MLUtils.unstack-Tuple{Any}"><code>MLUtils.unstack</code></a></li><li><a href="#MLUtils.unstack"><code>MLUtils.unstack</code></a></li></ul><h2 id="Docs"><a class="docs-heading-anchor" href="#Docs">Docs</a><a id="Docs-1"></a><a class="docs-heading-anchor-permalink" href="#Docs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLUtils.batch-Tuple{Any}" href="#MLUtils.batch-Tuple{Any}"><code>MLUtils.batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">batch(xs)</code></pre><p>Batch the arrays in <code>xs</code> into a single array with  an extra dimension.</p><p>If the elements of <code>xs</code> are tuples, named tuples, or dicts,  the output will be of the same type. </p><p>See also <a href="#MLUtils.unbatch"><code>unbatch</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; batch([[1,2,3], 
              [4,5,6]])
3×2 Matrix{Int64}:
 1  4
 2  5
 3  6

julia&gt; batch([(a=[1,2], b=[3,4])
               (a=[5,6], b=[7,8])]) 
(a = [1 5; 2 6], b = [3 7; 4 8])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L202-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.batchseq" href="#MLUtils.batchseq"><code>MLUtils.batchseq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">batchseq(seqs, pad)</code></pre><p>Take a list of <code>N</code> sequences, and turn them into a single sequence where each item is a batch of <code>N</code>. Short sequences will be padded by <code>pad</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; batchseq([[1, 2, 3], [4, 5]], 0)
3-element Vector{Vector{Int64}}:
 [1, 4]
 [2, 5]
 [3, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L317-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.chunk-Tuple{Any, Any}" href="#MLUtils.chunk-Tuple{Any, Any}"><code>MLUtils.chunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chunk(x, n)</code></pre><p>Split <code>x</code> into <code>n</code> parts.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; chunk(1:10, 3)
3-element Vector{UnitRange{Int64}}:
 1:4
 5:8
 9:10

julia&gt; chunk(collect(1:10), 3)
3-element Vector{SubArray{Int64, 1, Vector{Int64}, Tuple{UnitRange{Int64}}, true}}:
 [1, 2, 3, 4]
 [5, 6, 7, 8]
 [9, 10]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L123-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.flatten-Tuple{AbstractArray}" href="#MLUtils.flatten-Tuple{AbstractArray}"><code>MLUtils.flatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flatten(x::AbstractArray)</code></pre><p>Reshape arbitrarly-shaped input into a matrix-shaped output, preserving the size of the last dimension.</p><p>See also <a href="#MLUtils.unsqueeze"><code>unsqueeze</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rand(3,4,5) |&gt; flatten |&gt; size
(12, 5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L338-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.group_counts-Tuple{Any}" href="#MLUtils.group_counts-Tuple{Any}"><code>MLUtils.group_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">group_counts(x)</code></pre><p>Count the number of times that each element of <code>x</code> appears.</p><p>See also <a href="#MLUtils.group_indices-Tuple{T} where T&lt;:(AbstractVector)"><code>group_indices</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; group_counts([&#39;a&#39;, &#39;b&#39;, &#39;b&#39;])
Dict{Char, Int64} with 2 entries:
  &#39;a&#39; =&gt; 1
  &#39;b&#39; =&gt; 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L146-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.group_indices-Tuple{T} where T&lt;:(AbstractVector)" href="#MLUtils.group_indices-Tuple{T} where T&lt;:(AbstractVector)"><code>MLUtils.group_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">group_indices(x) -&gt; Dict</code></pre><p>Computes the indices of elements in the vector <code>x</code> for each distinct value contained.  This information is useful for resampling strategies, such as stratified sampling.</p><p>See also <a href="#MLUtils.group_counts-Tuple{Any}"><code>group_counts</code></a>.</p><p><strong>Examples</strong></p><p>```julia julia&gt; x = [:yes, :no, :maybe, :yes];</p><p>julia&gt; group_indices(x) Dict{Symbol, Vector{Int64}} with 3 entries:   :yes   =&gt; [1, 4]   :maybe =&gt; [3]   :no    =&gt; [2]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L169-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.normalise-Tuple{AbstractArray}" href="#MLUtils.normalise-Tuple{AbstractArray}"><code>MLUtils.normalise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalise(x; dims=ndims(x), ϵ=1e-5)</code></pre><p>Normalise the array <code>x</code> to mean 0 and standard deviation 1 across the dimension(s) given by <code>dims</code>. Per default, <code>dims</code> is the last dimension. </p><p><code>ϵ</code> is a small additive factor added to the denominator for numerical stability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L357-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.stack-Tuple{Any}" href="#MLUtils.stack-Tuple{Any}"><code>MLUtils.stack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stack(xs; dims)</code></pre><p>Concatenate the given array of arrays <code>xs</code> into a single array along the given dimension <code>dims</code>.</p><p>See also <a href="#MLUtils.stack"><code>stack</code></a> and <a href="#MLUtils.batch"><code>batch</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; xs = [[1, 2], [3, 4], [5, 6]]
3-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 4]
 [5, 6]

julia&gt; stack(xs, dims=1)
3×2 Matrix{Int64}:
 1  2
 3  4
 5  6

julia&gt; stack(xs, dims=2)
2×3 Matrix{Int64}:
 1  3  5
 2  4  6

julia&gt; stack(xs, dims=3)
2×1×3 Array{Int64, 3}:
[:, :, 1] =
 1
 2

[:, :, 2] =
 3
 4

[:, :, 3] =
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L58-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.unbatch-Tuple{AbstractArray}" href="#MLUtils.unbatch-Tuple{AbstractArray}"><code>MLUtils.unbatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unbatch(x)</code></pre><p>Reverse of the <a href="#MLUtils.batch"><code>batch</code></a> operation, unstacking the last dimension of the array <code>x</code>.</p><p>See also <a href="#MLUtils.unstack"><code>unstack</code></a>.</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; unbatch([1 3 5 7;                      2 4 6 8]) 4-element Vector{Vector{Int64}}:  [1, 2]  [3, 4]  [5, 6]  [7, 8]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L269-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.unsqueeze-Tuple{AbstractArray}" href="#MLUtils.unsqueeze-Tuple{AbstractArray}"><code>MLUtils.unsqueeze</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsqueeze(x; dims)</code></pre><p>Return <code>x</code> reshaped into an array one dimensionality higher than <code>x</code>, where <code>dims</code> indicates in which dimension <code>x</code> is extended.</p><p>See also <a href="#MLUtils.flatten-Tuple{AbstractArray}"><code>flatten</code></a>, <a href="#MLUtils.stack"><code>stack</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unsqueeze([1 2; 3 4], dims=2)
2×1×2 Array{Int64, 3}:
[:, :, 1] =
 1
 3

[:, :, 2] =
 2
 4


julia&gt; xs = [[1, 2], [3, 4], [5, 6]]
3-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 4]
 [5, 6]

julia&gt; unsqueeze(xs, dims=1)
1×3 Matrix{Vector{Int64}}:
 [1, 2]  [3, 4]  [5, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.unsqueeze-Tuple{}" href="#MLUtils.unsqueeze-Tuple{}"><code>MLUtils.unsqueeze</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsqueeze(; dims)</code></pre><p>Returns a function which, acting on an array, inserts a dimension of size 1 at <code>dims</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rand(21, 22, 23) |&gt; unsqueeze(dims=2) |&gt; size
(21, 1, 22, 23)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L41-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.unstack-Tuple{Any}" href="#MLUtils.unstack-Tuple{Any}"><code>MLUtils.unstack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unstack(xs; dims)</code></pre><p>Unroll the given <code>xs</code> into an array of arrays along the given dimension <code>dims</code>.</p><p>See also <a href="#MLUtils.stack"><code>stack</code></a> and <a href="#MLUtils.unbatch"><code>unbatch</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unstack([1 3 5 7; 2 4 6 8], dims=2)
4-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 4]
 [5, 6]
 [7, 8]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L103-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.batch" href="#MLUtils.batch"><code>MLUtils.batch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">batch(xs)</code></pre><p>Batch the arrays in <code>xs</code> into a single array with  an extra dimension.</p><p>If the elements of <code>xs</code> are tuples, named tuples, or dicts,  the output will be of the same type. </p><p>See also <a href="#MLUtils.unbatch"><code>unbatch</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; batch([[1,2,3], 
              [4,5,6]])
3×2 Matrix{Int64}:
 1  4
 2  5
 3  6

julia&gt; batch([(a=[1,2], b=[3,4])
               (a=[5,6], b=[7,8])]) 
(a = [1 5; 2 6], b = [3 7; 4 8])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L202-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.batchsize" href="#MLUtils.batchsize"><code>MLUtils.batchsize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">batchsize(data) -&gt; Int</code></pre><p>Return the fixed size of each batch in <code>data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/batchview.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.batchview" href="#MLUtils.batchview"><code>MLUtils.batchview</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchView(data, batchsize; partial=true)
BatchView(data; batchsize=1, partial=true)</code></pre><p>Create a view of the given <code>data</code> that represents it as a vector of batches. Each batch will contain an equal amount of observations in them. The batch-size can be specified using the  parameter <code>batchsize</code>. In the case that the size of the dataset is not dividable by the specified <code>batchsize</code>, the remaining observations will be ignored if <code>partial=false</code>. If  <code>partial=true</code> instead  the last batch-size can be slightly smaller.</p><p>Note that any data access is delayed until <code>getindex</code> is called, and even <code>getindex</code> returns an <a href="#MLUtils.ObsView"><code>ObsView</code></a> which in general avoids data movement until <a href="#MLUtils.getobs"><code>getobs</code></a> is called.</p><p>If used as an iterator, the object will iterate over the dataset once, effectively denoting an epoch. </p><p>For <code>BatchView</code> to work on some data structure, the type of the given variable <code>data</code> must implement the data container interface. See <a href="#MLUtils.ObsView"><code>ObsView</code></a> for more info.</p><p><strong>Arguments</strong></p><ul><li><p><strong><code>data</code></strong> : The object describing the dataset. Can be of any   type as long as it implements <a href="#MLUtils.getobs"><code>getobs</code></a> and   <a href="#MLUtils.numobs"><code>numobs</code></a> (see Details for more information).</p></li><li><p><strong><code>batchsize</code></strong> : The batch-size of each batch.    It is the number of observations that each batch must contain   (except possibly for the last one).</p></li><li><p><strong><code>partial</code></strong> : If <code>partial=false</code> and the number of observations is    not divisible by the batch-size, then the last mini-batch is dropped.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MLUtils
X, Y = MLUtils.load_iris()

A = batchview(X, batchsize=30)
@assert typeof(A) &lt;: BatchView &lt;: AbstractVector
@assert eltype(A) &lt;: SubArray{Float64,2}
@assert length(A) == 5 # Iris has 150 observations
@assert size(A[1]) == (4,30) # Iris has 4 features

# 5 batches of size 30 observations
for x in batchview(X, batchsize=30)
    @assert typeof(x) &lt;: SubArray{Float64,2}
    @assert numobs(x) === 30
end

# 7 batches of size 20 observations
# Note that the iris dataset has 150 observations,
# which means that with a batchsize of 20, the last
# 10 observations will be ignored
for (x, y) in batchview((X, Y), batchsize=20, partial=false)
    @assert typeof(x) &lt;: SubArray{Float64,2}
    @assert typeof(y) &lt;: SubArray{String,1}
    @assert numobs(x) == numobs(y) == 20
end


# randomly assign observations to one and only one batch.
for (x, y) in batchview(shuffleobs((X, Y)), batchsize=20)
    @assert typeof(x) &lt;: SubArray{Float64,2}
    @assert typeof(y) &lt;: SubArray{String,1}
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/batchview.jl#L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.BatchView" href="#MLUtils.BatchView"><code>MLUtils.BatchView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchView(data, batchsize; partial=true)
BatchView(data; batchsize=1, partial=true)</code></pre><p>Create a view of the given <code>data</code> that represents it as a vector of batches. Each batch will contain an equal amount of observations in them. The batch-size can be specified using the  parameter <code>batchsize</code>. In the case that the size of the dataset is not dividable by the specified <code>batchsize</code>, the remaining observations will be ignored if <code>partial=false</code>. If  <code>partial=true</code> instead  the last batch-size can be slightly smaller.</p><p>Note that any data access is delayed until <code>getindex</code> is called, and even <code>getindex</code> returns an <a href="#MLUtils.ObsView"><code>ObsView</code></a> which in general avoids data movement until <a href="#MLUtils.getobs"><code>getobs</code></a> is called.</p><p>If used as an iterator, the object will iterate over the dataset once, effectively denoting an epoch. </p><p>For <code>BatchView</code> to work on some data structure, the type of the given variable <code>data</code> must implement the data container interface. See <a href="#MLUtils.ObsView"><code>ObsView</code></a> for more info.</p><p><strong>Arguments</strong></p><ul><li><p><strong><code>data</code></strong> : The object describing the dataset. Can be of any   type as long as it implements <a href="#MLUtils.getobs"><code>getobs</code></a> and   <a href="#MLUtils.numobs"><code>numobs</code></a> (see Details for more information).</p></li><li><p><strong><code>batchsize</code></strong> : The batch-size of each batch.    It is the number of observations that each batch must contain   (except possibly for the last one).</p></li><li><p><strong><code>partial</code></strong> : If <code>partial=false</code> and the number of observations is    not divisible by the batch-size, then the last mini-batch is dropped.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using MLUtils
X, Y = MLUtils.load_iris()

A = batchview(X, batchsize=30)
@assert typeof(A) &lt;: BatchView &lt;: AbstractVector
@assert eltype(A) &lt;: SubArray{Float64,2}
@assert length(A) == 5 # Iris has 150 observations
@assert size(A[1]) == (4,30) # Iris has 4 features

# 5 batches of size 30 observations
for x in batchview(X, batchsize=30)
    @assert typeof(x) &lt;: SubArray{Float64,2}
    @assert numobs(x) === 30
end

# 7 batches of size 20 observations
# Note that the iris dataset has 150 observations,
# which means that with a batchsize of 20, the last
# 10 observations will be ignored
for (x, y) in batchview((X, Y), batchsize=20, partial=false)
    @assert typeof(x) &lt;: SubArray{Float64,2}
    @assert typeof(y) &lt;: SubArray{String,1}
    @assert numobs(x) == numobs(y) == 20
end


# randomly assign observations to one and only one batch.
for (x, y) in batchview(shuffleobs((X, Y)), batchsize=20)
    @assert typeof(x) &lt;: SubArray{Float64,2}
    @assert typeof(y) &lt;: SubArray{String,1}
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/batchview.jl#L1-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.DataLoader" href="#MLUtils.DataLoader"><code>MLUtils.DataLoader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DataLoader(data; batchsize=1, shuffle=false, partial=true, rng=GLOBAL_RNG)</code></pre><p>An object that iterates over mini-batches of <code>data</code>,  each mini-batch containing <code>batchsize</code> observations (except possibly the last one).</p><p>Takes as input a single data tensor, or a tuple (or a named tuple) of tensors. The last dimension in each tensor is the observation dimension, i.e. the one divided into mini-batches.</p><p>If <code>shuffle=true</code>, it shuffles the observations each time iterations are re-started. If <code>partial=false</code> and the number of observations is not divisible by the batchsize,  then the last mini-batch is dropped.</p><p>The original data is preserved in the <code>data</code> field of the DataLoader.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Xtrain = rand(10, 100);

julia&gt; array_loader = DataLoader(Xtrain, batchsize=2);

julia&gt; for x in array_loader
         @assert size(x) == (10, 2)
         # do something with x, 50 times
       end

julia&gt; array_loader.data === Xtrain
true

julia&gt; tuple_loader = DataLoader((Xtrain,), batchsize=2);  # similar, but yielding 1-element tuples

julia&gt; for x in tuple_loader
         @assert x isa Tuple{Matrix}
         @assert size(x[1]) == (10, 2)
       end

julia&gt; Ytrain = rand(&#39;a&#39;:&#39;z&#39;, 100);  # now make a DataLoader yielding 2-element named tuples

julia&gt; train_loader = DataLoader((data=Xtrain, label=Ytrain), batchsize=5, shuffle=true);

julia&gt; for epoch in 1:100
         for (x, y) in train_loader  # access via tuple destructuring
           @assert size(x) == (10, 5)
           @assert size(y) == (5,)
           # loss += f(x, y) # etc, runs 100 * 20 times
         end
       end

julia&gt; first(train_loader).label isa Vector{Char}  # access via property name
true

julia&gt; first(train_loader).label == Ytrain[1:5]  # because of shuffle=true
false

julia&gt; foreach(println∘summary, DataLoader(rand(Int8, 10, 64), batchsize=30))  # partial=false would omit last
10×30 Matrix{Int8}
10×30 Matrix{Int8}
10×4 Matrix{Int8}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/dataloader.jl#L12-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.eachobs" href="#MLUtils.eachobs"><code>MLUtils.eachobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eachobs(data, buffer=false, batchsize=-1, partial=true)</code></pre><p>Return an iterator over the observations in <code>data</code>. </p><p><strong>Arguments.</strong></p><ul><li><code>data</code>. The data to be iterated over. The data type has to implement  <a href="#MLUtils.numobs"><code>numobs</code></a> and <a href="#MLUtils.getobs"><code>getobs</code></a>. </li><li><code>buffer</code>. If <code>buffer=true</code> and supported by the type of <code>data</code>, </li></ul><p>a buffer will be allocated and reused for memory efficiency. You can also pass a preallocated object to <code>buffer</code>.</p><ul><li><code>batchsize</code>. If less than 0, iterates over individual observation. </li></ul><p>Otherwise, each iteration (except possibly the last) yields a mini-batch  containing <code>batchsize</code> observations.</p><ul><li><code>partial</code>. This argument is used only when <code>batchsize &gt; 0</code>. If <code>partial=false</code> and the number of observations is not divisible by the batchsize,  then the last mini-batch is dropped.</li></ul><p>See also <a href="#MLUtils.numobs"><code>numobs</code></a>, <a href="#MLUtils.getobs"><code>getobs</code></a> and <a href="#MLUtils.batchview"><code>batchview</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">X = rand(4,100)
for x in eachobs(X)
    # loop entered 100 times
    @assert typeof(x) &lt;: Vector{Float64}
    @assert size(x) == (4,)
end

# mini-batch iterations
for x in eachobs(X, batchsize=10)
    # loop entered 10 times
    @assert typeof(x) &lt;: Matrix{Float64}
    @assert size(x) == (4,10)
end

# support for tuples, named tuples, dicts
for (x, y) in eachobs((X, Y))
    # ...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/eachobs.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.filterobs" href="#MLUtils.filterobs"><code>MLUtils.filterobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filterobs(f, data)</code></pre><p>Return a subset of data container <code>data</code> including all indices <code>i</code> for which <code>f(getobs(data, i)) === true</code>.</p><pre><code class="language-julia hljs">data = 1:10
numobs(data) == 10
fdata = filterobs(&gt;(5), data)
numobs(fdata) == 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/obstransform.jl#L80-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.getobs" href="#MLUtils.getobs"><code>MLUtils.getobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getobs(data, [idx])</code></pre><p>Return the observations corresponding to the observation-index <code>idx</code>. Note that <code>idx</code> can be any type as long as <code>data</code> has defined <code>getobs</code> for that type.</p><p>The returned observation(s) should be in the form intended to be passed as-is to some learning algorithm. There is no strict interface requirement on how this &quot;actual data&quot; must look like.</p><p>Every author behind some custom data container can make this decision themselves.</p><p>The output should be consistent when <code>idx</code> is a scalar vs vector.</p><p>See also <a href="#MLUtils.getobs!"><code>getobs!</code></a> and <a href="#MLUtils.numobs"><code>numobs</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/observation.jl#L10-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.getobs!" href="#MLUtils.getobs!"><code>MLUtils.getobs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getobs!(buffer, data, idx)</code></pre><p>Inplace version of <code>getobs(data, idx)</code>. If this method is defined for the type of <code>data</code>, then <code>buffer</code> should be used to store the result, instead of allocating a dedicated object.</p><p>Implementing this function is optional. In the case no such method is provided for the type of <code>data</code>, then <code>buffer</code> will be <em>ignored</em> and the result of <a href="#MLUtils.getobs"><code>getobs</code></a> returned. This could be because the type of <code>data</code> may not lend itself to the concept of <code>copy!</code>. Thus, supporting a custom <code>getobs!</code> is optional and not required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/observation.jl#L34-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.joinobs" href="#MLUtils.joinobs"><code>MLUtils.joinobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">joinobs(datas...)</code></pre><p>Concatenate data containers <code>datas</code>.</p><pre><code class="language-julia hljs">data1, data2 = 1:10, 11:20
jdata = joinumobs(data1, data2)
getobs(jdata, 15) == 15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/obstransform.jl#L148-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.groupobs" href="#MLUtils.groupobs"><code>MLUtils.groupobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">groupobs(f, data)</code></pre><p>Split data container data <code>data</code> into different data containers, grouping observations by <code>f(obs)</code>.</p><pre><code class="language-julia hljs">data = -10:10
datas = groupobs(&gt;(0), data)
length(datas) == 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/obstransform.jl#L102-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.kfolds" href="#MLUtils.kfolds"><code>MLUtils.kfolds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kfolds(n::Integer, k = 5) -&gt; Tuple</code></pre><p>Compute the train/validation assignments for <code>k</code> repartitions of <code>n</code> observations, and return them in the form of two vectors. The first vector contains the index-vectors for the training subsets, and the second vector the index-vectors for the validation subsets respectively. A general rule of thumb is to use either <code>k = 5</code> or <code>k = 10</code>. The following code snippet generates the indices assignments for <code>k = 5</code></p><pre><code class="language-julia hljs">julia&gt; train_idx, val_idx = kfolds(10, 5);</code></pre><p>Each observation is assigned to the validation subset once (and only once). Thus, a union over all validation index-vectors reproduces the full range <code>1:n</code>. Note that there is no random assignment of observations to subsets, which means that adjacent observations are likely to be part of the same validation subset.</p><pre><code class="language-julia hljs">julia&gt; train_idx
5-element Array{Array{Int64,1},1}:
 [3,4,5,6,7,8,9,10]
 [1,2,5,6,7,8,9,10]
 [1,2,3,4,7,8,9,10]
 [1,2,3,4,5,6,9,10]
 [1,2,3,4,5,6,7,8]

julia&gt; val_idx
5-element Array{UnitRange{Int64},1}:
 1:2
 3:4
 5:6
 7:8
 9:10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/folds.jl#L2-L40">source</a></section><section><div><pre><code class="nohighlight hljs">kfolds(data, [k = 5])</code></pre><p>Repartition a <code>data</code> container <code>k</code> times using a <code>k</code> folds strategy and return the sequence of folds as a lazy iterator.  Only data subsets are created, which means that no actual data is copied until <a href="#MLUtils.getobs"><code>getobs</code></a> is invoked.</p><p>Conceptually, a k-folds repartitioning strategy divides the given <code>data</code> into <code>k</code> roughly equal-sized parts. Each part will serve as validation set once, while the remaining parts are used for training. This results in <code>k</code> different partitions of <code>data</code>.</p><p>In the case that the size of the dataset is not dividable by the specified <code>k</code>, the remaining observations will be evenly distributed among the parts.</p><pre><code class="language-julia hljs">for (x_train, x_val) in kfolds(X, k=10)
    # code called 10 times
    # nobs(x_val) may differ up to ±1 over iterations
end</code></pre><p>Multiple variables are supported (e.g. for labeled data)</p><pre><code class="language-julia hljs">for ((x_train, y_train), val) in kfolds((X, Y), k=10)
    # ...
end</code></pre><p>By default the folds are created using static splits. Use <a href="#MLUtils.shuffleobs"><code>shuffleobs</code></a> to randomly assign observations to the folds.</p><pre><code class="language-julia hljs">for (x_train, x_val) in kfolds(shuffleobs(X), k = 10)
    # ...
end</code></pre><p>See <a href="#MLUtils.leavepout"><code>leavepout</code></a> for a related function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/folds.jl#L62-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.leavepout" href="#MLUtils.leavepout"><code>MLUtils.leavepout</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leavepout(n::Integer, [size = 1]) -&gt; Tuple</code></pre><p>Compute the train/validation assignments for <code>k ≈ n/size</code> repartitions of <code>n</code> observations, and return them in the form of two vectors. The first vector contains the index-vectors for the training subsets, and the second vector the index-vectors for the validation subsets respectively. Each validation subset will have either <code>size</code> or <code>size+1</code> observations assigned to it. The following code snippet generates the index-vectors for <code>size = 2</code>.</p><pre><code class="language-julia hljs">julia&gt; train_idx, val_idx = leavepout(10, 2);</code></pre><p>Each observation is assigned to the validation subset once (and only once). Thus, a union over all validation index-vectors reproduces the full range <code>1:n</code>. Note that there is no random assignment of observations to subsets, which means that adjacent observations are likely to be part of the same validation subset.</p><pre><code class="language-julia hljs">julia&gt; train_idx
5-element Array{Array{Int64,1},1}:
 [3,4,5,6,7,8,9,10]
 [1,2,5,6,7,8,9,10]
 [1,2,3,4,7,8,9,10]
 [1,2,3,4,5,6,9,10]
 [1,2,3,4,5,6,7,8]

julia&gt; val_idx
5-element Array{UnitRange{Int64},1}:
 1:2
 3:4
 5:6
 7:8
 9:10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/folds.jl#L116-L154">source</a></section><section><div><pre><code class="nohighlight hljs">leavepout(data, p = 1)</code></pre><p>Repartition a <code>data</code> container using a k-fold strategy, where <code>k</code> is chosen in such a way, that each validation subset of the resulting folds contains roughly <code>p</code> observations. Defaults to <code>p = 1</code>, which is also known as &quot;leave-one-out&quot; partitioning.</p><p>The resulting sequence of folds is returned as a lazy iterator. Only data subsets are created. That means no actual data is copied until <a href="#MLUtils.getobs"><code>getobs</code></a> is invoked.</p><pre><code class="language-julia hljs">for (train, val) in leavepout(X, p=2)
    # if nobs(X) is dividable by 2,
    # then numobs(val) will be 2 for each iteraton,
    # otherwise it may be 3 for the first few iterations.
end</code></pre><p>See<a href="#MLUtils.kfolds"><code>kfolds</code></a> for a related function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/folds.jl#L161-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.mapobs" href="#MLUtils.mapobs"><code>MLUtils.mapobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapobs(f, data)</code></pre><p>Lazily map <code>f</code> over the observations in a data container <code>data</code>.</p><pre><code class="language-julia hljs">data = 1:10
getobs(data, 8) == 8
mdata = mapobs(-, data)
getobs(mdata, 8) == -8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/obstransform.jl#L17-L27">source</a></section><section><div><pre><code class="nohighlight hljs">mapobs(fs, data)</code></pre><p>Lazily map each function in tuple <code>fs</code> over the observations in data container <code>data</code>. Returns a tuple of transformed data containers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/obstransform.jl#L32-L37">source</a></section><section><div><pre><code class="nohighlight hljs">mapobs(namedfs::NamedTuple, data)</code></pre><p>Map a <code>NamedTuple</code> of functions over <code>data</code>, turning it into a data container of <code>NamedTuple</code>s. Field syntax can be used to select a column of the resulting data container.</p><pre><code class="language-julia hljs">data = 1:10
nameddata = mapobs((x = sqrt, y = log), data)
getobs(nameddata, 10) == (x = sqrt(10), y = log(10))
getobs(nameddata.x, 10) == sqrt(10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/obstransform.jl#L60-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.numobs" href="#MLUtils.numobs"><code>MLUtils.numobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numobs(data)</code></pre><p>Return the total number of observations contained in <code>data</code>.</p><p>See also <a href="#MLUtils.getobs"><code>getobs</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/observation.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.obsview" href="#MLUtils.obsview"><code>MLUtils.obsview</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">obsview(data, [indices])</code></pre><p>Returns a lazy view of the observations in <code>data</code> that correspond to the given <code>indices</code>. No data will be copied except of the indices. It is similar to constructing an <a href="#MLUtils.ObsView"><code>ObsView</code></a>,  but returns a <code>SubArray</code> if the type of <code>data</code> is <code>Array</code> or <code>SubArray</code>. Furthermore, this function may be extended for custom types of <code>data</code> that also want to provide their own subset-type.</p><p>In case <code>data</code> is a tuple, the constructor will be mapped over its elements. That means that the constructor returns a tuple of <code>ObsView</code> instead of a <code>ObsView</code> of tuples.</p><p>If instead you want to get the subset of observations corresponding to the given <code>indices</code> in their native type, use <code>getobs</code>.</p><p>See <a href="#MLUtils.ObsView"><code>ObsView</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/obsview.jl#L198-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.ObsView" href="#MLUtils.ObsView"><code>MLUtils.ObsView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ObsView(data, [indices])</code></pre><p>Used to represent a subset of some <code>data</code> of arbitrary type by storing which observation-indices the subset spans. Furthermore, subsequent subsettings are accumulated without needing to access actual data.</p><p>The main purpose for the existence of <code>ObsView</code> is to delay data access and movement until an actual batch of data (or single observation) is needed for some computation. This is particularily useful when the data is not located in memory, but on the hard drive or some remote location. In such a scenario one wants to load the required data only when needed.</p><p>Any data access is delayed until <code>getindex</code> is called,  and even <code>getindex</code> returns the result of <a href="#MLUtils.obsview"><code>obsview</code></a> which in general avoids data movement until <a href="#MLUtils.getobs"><code>getobs</code></a> is called. If used as an iterator, the view will iterate over the dataset once, effectively denoting an epoch. Each iteration will return a lazy subset to the current observation.</p><p><strong>Arguments</strong></p><ul><li><p><strong><code>data</code></strong> : The object describing the dataset. Can be of any   type as long as it implements <a href="#MLUtils.getobs"><code>getobs</code></a> and   <a href="#MLUtils.numobs"><code>numobs</code></a> (see Details for more information).</p></li><li><p><strong><code>indices</code></strong> : Optional. The index or indices of the   observation(s) in <code>data</code> that the subset should represent.   Can be of type <code>Int</code> or some subtype of <code>AbstractVector</code>.</p></li></ul><p><strong>Methods</strong></p><ul><li><p><strong><code>getindex</code></strong> : Returns the observation(s) of the given   index/indices. No data is copied aside   from the required indices.</p></li><li><p><strong><code>numobs</code></strong> : Returns the total number observations in the subset.</p></li><li><p><strong><code>getobs</code></strong> : Returns the underlying data that the   <code>ObsView</code> represents at the given relative indices. Note   that these indices are in &quot;subset space&quot;, and in general will   not directly correspond to the same indices in the underlying   data set.</p></li></ul><p><strong>Details</strong></p><p>For <code>ObsView</code> to work on some data structure, the desired type <code>MyType</code> must implement the following interface:</p><ul><li><p><code>getobs(data::MyType, idx)</code> :   Should return the observation(s) indexed by <code>idx</code>.   In what form is up to the user.   Note that <code>idx</code> can be of type <code>Int</code> or <code>AbstractVector</code>.</p></li><li><p><code>numobs(data::MyType)</code> :   Should return the total number of observations in <code>data</code></p></li></ul><p>The following methods can also be provided and are optional:</p><ul><li><p><code>getobs(data::MyType)</code> :   By default this function is the identity function.   If that is not the behaviour that you want for your type,   you need to provide this method as well.</p></li><li><p><code>obsview(data::MyType, idx)</code> :   If your custom type has its own kind of subset type, you can   return it here. An example for such a case are <code>SubArray</code> for   representing a subset of some <code>AbstractArray</code>.</p></li><li><p><code>getobs!(buffer, data::MyType, [idx])</code> :   Inplace version of <code>getobs(data, idx)</code>. If this method   is provided for <code>MyType</code>, then <code>eachobs</code> can preallocate a buffer that is then reused   every iteration. Note: <code>buffer</code> should be equivalent to the   return value of <code>getobs(::MyType, ...)</code>, since this is how   <code>buffer</code> is preallocated by default.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">X, Y = MLUtils.load_iris()

# The iris set has 150 observations and 4 features
@assert size(X) == (4,150)

# Represents the 80 observations as a ObsView
v = ObsView(X, 21:100)
@assert numobs(v) == 80
@assert typeof(v) &lt;: ObsView
# getobs indexes into v
@assert getobs(v, 1:10) == X[:, 21:30]

# Use `obsview` to avoid boxing into ObsView
# for types that provide a custom &quot;subset&quot;, such as arrays.
# Here it instead creates a native SubArray.
v = obsview(X, 1:100)
@assert numobs(v) == 100
@assert typeof(v) &lt;: SubArray

# Also works for tuples of arbitrary length
subset = obsview((X, Y), 1:100)
@assert numobs(subset) == 100
@assert typeof(subset) &lt;: Tuple # tuple of SubArray

# Use as iterator
for x in ObsView(X)
    @assert typeof(x) &lt;: SubArray{Float64,1}
end

# iterate over each individual labeled observation
for (x, y) in ObsView((X, Y))
    @assert typeof(x) &lt;: SubArray{Float64,1}
    @assert typeof(y) &lt;: String
end

# same but in random order
for (x, y) in ObsView(shuffleobs((X, Y)))
    @assert typeof(x) &lt;: SubArray{Float64,1}
    @assert typeof(y) &lt;: String
end

# Indexing: take first 10 observations
x, y = ObsView((X, Y))[1:10]</code></pre><p><strong>See also</strong></p><p><a href="#MLUtils.obsview"><code>obsview</code></a>,  <a href="#MLUtils.getobs"><code>getobs</code></a>, <a href="#MLUtils.numobs"><code>numobs</code></a>, <a href="#MLUtils.splitobs"><code>splitobs</code></a>, <a href="#MLUtils.shuffleobs"><code>shuffleobs</code></a>, <a href="#MLUtils.kfolds"><code>kfolds</code></a>, <a href="#MLUtils.batchview"><code>batchview</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/obsview.jl#L1-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.oversample" href="#MLUtils.oversample"><code>MLUtils.oversample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">oversample(data, classes; fraction=1, shuffle=true)
oversample(data::Tuple; fraction=1, shuffle=true)</code></pre><p>Generate a re-balanced version of <code>data</code> by repeatedly sampling existing observations in such a way that every class will have at least <code>fraction</code> times the number observations of the largest class in <code>classes</code>. This way, all classes will have a minimum number of observations in the resulting data set relative to what largest class has in the given (original) <code>data</code>.</p><p>As an example, by default (i.e. with <code>fraction = 1</code>) the resulting dataset will be near perfectly balanced. On the other hand, with <code>fraction = 0.5</code> every class in the resulting data with have at least 50% as many observations as the largest class.</p><p>The <code>classes</code> input is an array with the same length as <code>numobs(data)</code>.  </p><p>The convenience parameter <code>shuffle</code> determines if the resulting data will be shuffled after its creation; if it is not shuffled then all the repeated samples will be together at the end, sorted by class. Defaults to <code>true</code>.</p><pre><code class="language-julia hljs"># 6 observations with 3 features each
X = rand(3, 6)
# 2 classes, severely imbalanced
Y = [&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;]

# oversample the class &quot;a&quot; to match &quot;b&quot;
X_bal, Y_bal = oversample(X, Y)

# this results in a bigger dataset with repeated data
@assert size(X_bal) == (3,8)
@assert length(Y_bal) == 8

# now both &quot;a&quot;, and &quot;b&quot; have 4 observations each
@assert sum(Y_bal .== &quot;a&quot;) == 4
@assert sum(Y_bal .== &quot;b&quot;) == 4</code></pre><p>For this function to work, the type of <code>data</code> must implement <a href="#MLUtils.numobs"><code>numobs</code></a> and <a href="#MLUtils.getobs"><code>getobs</code></a>. For example, the following code allows <code>oversample</code> to work on a <code>DataFrame</code>.</p><pre><code class="language-julia hljs"># Make DataFrames.jl work
MLUtils.getobs(data::DataFrame, i) = data[i,:]
MLUtils.numobs(data::DataFrame) = nrow(data)</code></pre><p>Note that if <code>data</code> is a tuple and <code>classes</code> is not given,  then it will be assumed that the last element of the tuple contains the classes.</p><pre><code class="language-julia hljs">julia&gt; data = DataFrame(X1=rand(6), X2=rand(6), Y=[:a,:b,:b,:b,:b,:a])
6×3 DataFrames.DataFrame
│ Row │ X1        │ X2          │ Y │
├─────┼───────────┼─────────────┼───┤
│ 1   │ 0.226582  │ 0.0443222   │ a │
│ 2   │ 0.504629  │ 0.722906    │ b │
│ 3   │ 0.933372  │ 0.812814    │ b │
│ 4   │ 0.522172  │ 0.245457    │ b │
│ 5   │ 0.505208  │ 0.11202     │ b │
│ 6   │ 0.0997825 │ 0.000341996 │ a │

julia&gt; getobs(oversample(data, data.Y))
8×3 DataFrame
 Row │ X1        X2         Y      
     │ Float64   Float64    Symbol 
─────┼─────────────────────────────
   1 │ 0.376304  0.100022   a
   2 │ 0.467095  0.185437   b
   3 │ 0.481957  0.319906   b
   4 │ 0.336762  0.390811   b
   5 │ 0.376304  0.100022   a
   6 │ 0.427064  0.0648339  a
   7 │ 0.427064  0.0648339  a
   8 │ 0.457043  0.490688   b</code></pre><p>See <a href="#MLUtils.ObsView"><code>ObsView</code></a> for more information on data subsets. See also <a href="#MLUtils.undersample"><code>undersample</code></a> and <a href="@ref"><code>stratifiedobs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/resample.jl#L1-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rpad" href="#Base.rpad"><code>Base.rpad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rpad(v::AbstractVector, n::Integer, p)</code></pre><p>Return the given sequence padded with <code>p</code> up to a maximum length of <code>n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rpad([1, 2], 4, 0)
4-element Vector{Int64}:
 1
 2
 0
 0

julia&gt; rpad([1, 2, 3], 2, 0)
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L291-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.randobs" href="#MLUtils.randobs"><code>MLUtils.randobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">randobs(data, [n])</code></pre><p>Pick a random observation or a batch of <code>n</code> random observations from <code>data</code>. For this function to work, the type of <code>data</code> must implement <a href="#MLUtils.numobs"><code>numobs</code></a> and <a href="#MLUtils.getobs"><code>getobs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/randobs.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rpad-Tuple{AbstractVector, Integer, Any}" href="#Base.rpad-Tuple{AbstractVector, Integer, Any}"><code>Base.rpad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rpad(v::AbstractVector, n::Integer, p)</code></pre><p>Return the given sequence padded with <code>p</code> up to a maximum length of <code>n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rpad([1, 2], 4, 0)
4-element Vector{Int64}:
 1
 2
 0
 0

julia&gt; rpad([1, 2, 3], 2, 0)
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L291-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.shuffleobs" href="#MLUtils.shuffleobs"><code>MLUtils.shuffleobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shuffleobs([rng], data)</code></pre><p>Return a &quot;subset&quot; of <code>data</code> that spans all observations, but has the order of the observations shuffled.</p><p>The values of <code>data</code> itself are not copied. Instead only the indices are shuffled. This function calls <a href="#MLUtils.obsview"><code>obsview</code></a> to accomplish that, which means that the return value is likely of a different type than <code>data</code>.</p><pre><code class="language-julia hljs"># For Arrays the subset will be of type SubArray
@assert typeof(shuffleobs(rand(4,10))) &lt;: SubArray

# Iterate through all observations in random order
for x in eachobs(shuffleobs(X))
    ...
end</code></pre><p>The optional parameter <code>rng</code> allows one to specify the random number generator used for shuffling. This is useful when reproducible results are desired. By default, uses the global RNG. See <code>Random</code> in Julia&#39;s standard library for more info.</p><p>For this function to work, the type of <code>data</code> must implement <a href="#MLUtils.numobs"><code>numobs</code></a> and <a href="#MLUtils.getobs"><code>getobs</code></a>. See <a href="#MLUtils.ObsView"><code>ObsView</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/obstransform.jl#L161-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.splitobs" href="#MLUtils.splitobs"><code>MLUtils.splitobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">splitobs(n::Int; at) -&gt; Tuple</code></pre><p>Pre-compute the indices for two disjoint subsets and return them as a tuple of two ranges. The first range will span the first <code>at</code> fraction of possible indices, while the second range will cover the rest. These indices are applicable to any data container of size <code>n</code>.</p><pre><code class="language-julia hljs">julia&gt; splitobs(100, at=0.7)
(1:70, 71:100)</code></pre><p>A tuple <code>at</code> can be passed for multiple splits:</p><pre><code class="language-julia hljs">julia&gt; splitobs(100, at=(0.1, 0.4))
(1:10, 11:50, 51:100)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/splitobs.jl#L1-L21">source</a></section><section><div><pre><code class="nohighlight hljs">splitobs(data; at) -&gt; Tuple</code></pre><p>Split the <code>data</code> into multiple subsets proportional to the value(s) of <code>at</code>.</p><p>Note that this function will perform the splits statically and thus not perform any randomization. The function creates a <code>NTuple</code> of data subsets in which the first N-1 elements/subsets contain the fraction of observations of <code>data</code> that is specified by <code>at</code>.</p><p>For example, if <code>at</code> is a <code>Float64</code> then the return-value will be a tuple with two elements (i.e. subsets), in which the first element contains the fracion of observations specified by <code>at</code> and the second element contains the rest. In the following code the first subset <code>train</code> will contain the first 70% of the observations and the second subset <code>test</code> the rest.</p><pre><code class="language-julia hljs">train, test = splitobs(X, at=0.7)</code></pre><p>If <code>at</code> is a tuple of <code>Float64</code> then additional subsets will be created. In this example <code>train</code> will have the first 50% of the observations, <code>val</code> will have next 30%, and <code>test</code> the last 20%</p><pre><code class="language-julia hljs">train, val, test = splitobs(X, at=(0.5, 0.3))</code></pre><p>It is also possible to call <code>splitobs</code> with multiple data arguments as tuple, which all must have the same number of total observations. This is useful for labeled data.</p><pre><code class="language-julia hljs">train, test = splitobs((X, y), at=0.7)
(x_train,y_train), (x_test,y_test) = splitobs((X, y), at=0.7)</code></pre><p>If the observations should be randomly assigned to a subset, then you can combine the function with <code>shuffleobs</code></p><pre><code class="language-julia hljs"># This time observations are randomly assigned.
train, test = splitobs(shuffleobs((X, y)), at=0.7)</code></pre><p>See <a href="@ref"><code>stratifiedobs</code></a> for a related function that preserves the target distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/splitobs.jl#L45-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.stack" href="#MLUtils.stack"><code>MLUtils.stack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stack(xs; dims)</code></pre><p>Concatenate the given array of arrays <code>xs</code> into a single array along the given dimension <code>dims</code>.</p><p>See also <a href="#MLUtils.stack"><code>stack</code></a> and <a href="#MLUtils.batch"><code>batch</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; xs = [[1, 2], [3, 4], [5, 6]]
3-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 4]
 [5, 6]

julia&gt; stack(xs, dims=1)
3×2 Matrix{Int64}:
 1  2
 3  4
 5  6

julia&gt; stack(xs, dims=2)
2×3 Matrix{Int64}:
 1  3  5
 2  4  6

julia&gt; stack(xs, dims=3)
2×1×3 Array{Int64, 3}:
[:, :, 1] =
 1
 2

[:, :, 2] =
 3
 4

[:, :, 3] =
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L58-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.unbatch" href="#MLUtils.unbatch"><code>MLUtils.unbatch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unbatch(x)</code></pre><p>Reverse of the <a href="#MLUtils.batch"><code>batch</code></a> operation, unstacking the last dimension of the array <code>x</code>.</p><p>See also <a href="#MLUtils.unstack"><code>unstack</code></a>.</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; unbatch([1 3 5 7;                      2 4 6 8]) 4-element Vector{Vector{Int64}}:  [1, 2]  [3, 4]  [5, 6]  [7, 8]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L269-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.undersample" href="#MLUtils.undersample"><code>MLUtils.undersample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">undersample(data, classes; shuffle=true)</code></pre><p>Generate a class-balanced version of <code>data</code> by subsampling its observations in such a way that the resulting number of observations will be the same number for every class. This way, all classes will have as many observations in the resulting data set as the smallest class has in the given (original) <code>data</code>.</p><p>The convenience parameter <code>shuffle</code> determines if the resulting data will be shuffled after its creation; if it is not shuffled then all the observations will be in their original order. Defaults to <code>false</code>.</p><pre><code class="language-julia hljs"># 6 observations with 3 features each
X = rand(3, 6)
# 2 classes, severely imbalanced
Y = [&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;]

# subsample the class &quot;b&quot; to match &quot;a&quot;
X_bal, Y_bal = undersample(X, Y)

# this results in a smaller dataset
@assert size(X_bal) == (3,4)
@assert length(Y_bal) == 4

# now both &quot;a&quot;, and &quot;b&quot; have 2 observations each
@assert sum(Y_bal .== &quot;a&quot;) == 2
@assert sum(Y_bal .== &quot;b&quot;) == 2</code></pre><p>For this function to work, the type of <code>data</code> must implement <a href="#MLUtils.numobs"><code>numobs</code></a> and <a href="#MLUtils.getobs"><code>getobs</code></a>. For example, the following code allows <code>undersample</code> to work on a <code>DataFrame</code>.</p><pre><code class="language-julia hljs"># Make DataFrames.jl work
MLUtils.getobs(data::DataFrame, i) = data[i,:]
MLUtils.numobs(data::DataFrame) = nrow(data)</code></pre><p>Note that if <code>data</code> is a tuple, then it will be assumed that the last element of the tuple contains the targets.</p><pre><code class="language-julia hljs">julia&gt; data = DataFrame(X1=rand(6), X2=rand(6), Y=[:a,:b,:b,:b,:b,:a])
6×3 DataFrames.DataFrame
│ Row │ X1        │ X2          │ Y │
├─────┼───────────┼─────────────┼───┤
│ 1   │ 0.226582  │ 0.0443222   │ a │
│ 2   │ 0.504629  │ 0.722906    │ b │
│ 3   │ 0.933372  │ 0.812814    │ b │
│ 4   │ 0.522172  │ 0.245457    │ b │
│ 5   │ 0.505208  │ 0.11202     │ b │
│ 6   │ 0.0997825 │ 0.000341996 │ a │

julia&gt; getobs(undersample(data, data.Y))
4×3 DataFrame
 Row │ X1        X2         Y      
     │ Float64   Float64    Symbol 
─────┼─────────────────────────────
   1 │ 0.427064  0.0648339  a
   2 │ 0.376304  0.100022   a
   3 │ 0.467095  0.185437   b
   4 │ 0.457043  0.490688   b</code></pre><p>See <a href="#MLUtils.ObsView"><code>ObsView</code></a> for more information on data subsets. See also <a href="#MLUtils.oversample"><code>oversample</code></a> and <a href="@ref"><code>stratifiedobs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/resample.jl#L112-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.unsqueeze" href="#MLUtils.unsqueeze"><code>MLUtils.unsqueeze</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsqueeze(x; dims)</code></pre><p>Return <code>x</code> reshaped into an array one dimensionality higher than <code>x</code>, where <code>dims</code> indicates in which dimension <code>x</code> is extended.</p><p>See also <a href="#MLUtils.flatten-Tuple{AbstractArray}"><code>flatten</code></a>, <a href="#MLUtils.stack"><code>stack</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unsqueeze([1 2; 3 4], dims=2)
2×1×2 Array{Int64, 3}:
[:, :, 1] =
 1
 3

[:, :, 2] =
 2
 4


julia&gt; xs = [[1, 2], [3, 4], [5, 6]]
3-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 4]
 [5, 6]

julia&gt; unsqueeze(xs, dims=1)
1×3 Matrix{Vector{Int64}}:
 [1, 2]  [3, 4]  [5, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L3-L35">source</a></section><section><div><pre><code class="language-julia hljs">unsqueeze(; dims)</code></pre><p>Returns a function which, acting on an array, inserts a dimension of size 1 at <code>dims</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rand(21, 22, 23) |&gt; unsqueeze(dims=2) |&gt; size
(21, 1, 22, 23)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L41-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.unstack" href="#MLUtils.unstack"><code>MLUtils.unstack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unstack(xs; dims)</code></pre><p>Unroll the given <code>xs</code> into an array of arrays along the given dimension <code>dims</code>.</p><p>See also <a href="#MLUtils.stack"><code>stack</code></a> and <a href="#MLUtils.unbatch"><code>unbatch</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unstack([1 3 5 7; 2 4 6 8], dims=2)
4-element Vector{Vector{Int64}}:
 [1, 2]
 [3, 4]
 [5, 6]
 [7, 8]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/utils.jl#L103-L120">source</a></section></article><h2 id="Datasets-Docs"><a class="docs-heading-anchor" href="#Datasets-Docs">Datasets Docs</a><a id="Datasets-Docs-1"></a><a class="docs-heading-anchor-permalink" href="#Datasets-Docs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MLUtils.Datasets.load_iris" href="#MLUtils.Datasets.load_iris"><code>MLUtils.Datasets.load_iris</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_iris() -&gt; X, y, names</code></pre><p>Loads the first 150 observations from the Iris flower data set introduced by Ronald Fisher (1936). The 4 by 150 matrix <code>X</code> contains the numeric measurements, in which each individual column denotes an observation. The vector <code>y</code> contains the class labels as strings. The vector <code>names</code> contains the names of the features (i.e. rows of <code>X</code>)</p><p>[1] Fisher, Ronald A. &quot;The use of multiple measurements in taxonomic problems.&quot; Annals of eugenics 7.2 (1936): 179-188.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/Datasets/datasets.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.Datasets.make_sin" href="#MLUtils.Datasets.make_sin"><code>MLUtils.Datasets.make_sin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_sin(n, start, stop; noise = 0.3, f_rand = randn) -&gt; x, y</code></pre><p>Generates <code>n</code> noisy equally spaces samples of a sinus from <code>start</code> to <code>stop</code> by adding <code>noise .* f_rand(length(x))</code> to the result of <code>fun(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/Datasets/generators.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.Datasets.make_spiral" href="#MLUtils.Datasets.make_spiral"><code>MLUtils.Datasets.make_spiral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_spiral(n, a, theta, b; noise = 0.01, f_rand = randn) -&gt; x, y</code></pre><p>Generates <code>n</code> noisy responses for a spiral with two labels. Uses the radius, angle and scaling arguments to space the points in 2D space and adding <code>noise .* f_randn(n)</code> to the response.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/Datasets/generators.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MLUtils.Datasets.make_poly" href="#MLUtils.Datasets.make_poly"><code>MLUtils.Datasets.make_poly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_poly(coef, x; noise = 0.01, f_rand = randn) -&gt; x, y</code></pre><p>Generates a noisy response for a polynomial of degree <code>length(coef)</code> using the vector <code>x</code> as input and adding <code>noise .* f_randn(length(x))</code> to the result. The vector <code>coef</code> contains the coefficients for the terms of the polynome. The first element of <code>coef</code> denotes the coefficient for the term with the highest degree, while the last element of <code>coef</code> denotes the intercept.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaML/MLUtils.jl/blob/0f8406b32227d531ace398af41202b0ba07eecef/src/Datasets/generators.jl#L14-L22">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Saturday 5 February 2022 08:48">Saturday 5 February 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
